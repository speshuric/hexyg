# Написание приложения работы с hex значениями

## Суть задачи

Нужно сделать план написания приложения. Этот план должен быть оформлен в виде markdown списка todo, возможно иерархического. Отдельные задачи должны быть максимально приближены к тому, чтобы эти пункты могли реализовать LLM. Стоит учесть, что это первая редакция, она будет расширяться и дополняться.

Название приложения: hexator

Назначение приложения: конвертор-редактор hex.

## Основная информация о приложении

Ядро системы позволяет, используя заранее описанную грамматику:
- конвертировать бинарные наборы данных в текст, содержащий hex-значения
- конвертировать тексты в рамках данной грамматики в бинарные данные
- предоставляет LSP-сервер и плагины для редаторов и IDE.

Особенностями будут являться:
- возможности форматирования (сколько байт в строке, разделители, вывод адресов и т.п.), 
- комментирования: текст может содержать однострочные и многострочные комментарии
- выделение структур и форматирования значений: каким-то областям можно назначать имена и типы
- интерактивный и пакетный режим работы

## Базовые сценарии использования в командной строке (имена и команды примерные)

```bash
# Конвертирует бинарный input.binary в текстовый text.hex с настройками по умолчанию
hexator --bin-to-hex --input input.binary --output text.hex
```

```bash
# Проверяет синтаксическую корректность и конвертирует текстовый text.hex в бинарный input.binary с настройками по умолчанию
hexator --hex-to-bin --input text.hex --output input.binary
```

```bash
# Конвертирует строку GOOGLE в текст 474F4F474C45 (или подобный - зависит от настроек по умолчанию)
echo GOOGLE | hexator --bin-to-hex
# Выведет 474F4F474C45
```

```bash
# Конвертирует строку 474F4F474C45 в текст GOOGLE
echo 474F4F474C45 | hexator --hex-to-bin
# Выведет GOOGLE
```

### Зачем это нужно

Такой набор утилит позволит отказаться от хранения бинарных файлов в репозиториях git с исходными текстами, формируя бинарные файлы (для релизов или для тестов) в момент сборки. При этом можно будет анализировать diff в pull request (так как hex файлы уже текстовые). Возможности задания структур и комментариев пригодятся для тех же целей. 

При этом зачастую исходные данные идут в бинарном виде (reverse engineering или результат запуска), поэтому инструмент нужен двусторонний.
Редактирование в виде обычного текста может быть непродуктивным, поэтому нужны LSP и плагины к редакторам и IDE

## Грамматика

Базово hex текст это что-то такое:

```
#option bin_filename=lorem.bin
#option encoding=utf8
#option endian=LITTLE_ENDIAN
#option address_size=u32
#option padding=00 // FF или другое значение или padding=forbidden для запрета пропусков

// следующие настройки нужны скорее для парсинга или переформатирования, из hex в bin они конвертировать не мешают
#option line_length=16 
#option block_length=1 // чтобы строка была "4C 6F 72 65 6D 20 69 70 73 75 6D 20 64 6F 6C 6F"
#option repeat_adress=every_line

// комментарии в C/Java стиле
// пустые строки и пробелы не значат

00000000: 4C 6F 72 65 6D 20 69 70 73 75 6D 20 64 6F 6C 6F [Lorem ipsum dolo]
00000010: 72 20 73 69 74 20 61 6D 65 74 2C 20 63 6F 6E 73 [r sit amet, cons]
00000020: 65 63 74 65 74 75 72 20 61 64 69 70 69 73 63 69 [ectetur adipisci]
00000030: 6E 67 20 65 6C 69 74 2C 20 73 65 64 20 64 6F 20 [ng elit, sed do ]
00000040: 65 69 75 73 6D 6F 64 20 74 65 6D 70 6F 72 20 69 [eiusmod tempor i]
00000050: 6E 63 69 64 69 64 75 6E 74 20 75 74 20 6C 61 62 [ncididunt ut lab]
00000060: 6F 72 65 20 65 74 20 64 6F 6C 6F 72 65 20 6D 61 [ore et dolore ma]
00000070: 67 6E 61 20 61 6C 69 71 75 61 2E                [gna aliqua.]

// в квадратных скобках текстовое представление
// адрес обязательно завершается двоеточием и начинается с начала строки
// адрес начала по умолчанию - 0
// Если padding разрешён, то "дырки" в адресах допустимы

00000100: 00 01 02 03 // возможно и такое представление
          04 05 06 07

00000108: 
08090A0B
0C0D0E0F 
// то же самое что "00000108: 08090A0B0C0D0E0F"

// после "|" могут быть значения
00000200: FF 00 00 00 EE EE 00 00 | +0:u32=255 +03:u32=61166 // по адресам
00000208: 01 00 00 00 02 00 03 00 | u32=1 u16=2 u16=3 // последовательно без адресов
00000210: 01 00 00 00 02 00 03 00 | +00(name_x):u32=1 +03(name_y):u16=2 +03(name_z):u16=3 // с именами
// структуры будут в будущих версиях, сейчас это для демонстрации синтаксиса
#struct data {
    name_x:u32, 
    name_y:u16, 
    name_z:u16, 
}
00000218: 01 00 00 00 02 00 03 00 | +00:data={name_x=1, name_y=2, name_z=3} //json-подобное. 
00000220: 4C 6F 72 65 6D 20 69 70 | +00:utf8="Lorem ipsum dolo"
          73 75 6D 20 64 6F 6C 6F 
// Структуры простые, никаких рекурсий, конечно. Но вложеность возможна.

// представления и значения могут комбинироваться
00000300: 4C 6F 72 65 6D 20 69 70 73 75 6D 20 64 6F 6C 6F [Lorem ipsum dolo] | +00:utf8="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
00000310: 72 20 73 69 74 20 61 6D 65 74 2C 20 63 6F 6E 73 [r sit amet, cons]
00000320: 65 63 74 65 74 75 72 20 61 64 69 70 69 73 63 69 [ectetur adipisci]
00000330: 6E 67 20 65 6C 69 74 2C 20 73 65 64 20 64 6F 20 [ng elit, sed do ]
00000340: 65 69 75 73 6D 6F 64 20 74 65 6D 70 6F 72 20 69 [eiusmod tempor i]
00000350: 6E 63 69 64 69 64 75 6E 74 20 75 74 20 6C 61 62 [ncididunt ut lab]
00000360: 6F 72 65 20 65 74 20 64 6F 6C 6F 72 65 20 6D 61 [ore et dolore ma]
00000370: 67 6E 61 20 61 6C 69 71 75 61 2E                [gna aliqua.]

```
## Использование в редакторах

Основная задача при использовании hexator в редакторах - обеспечить удобство редактирования и консистентность hex-представления-значений. Ну и всякие проверки типа пересечения адресов и т.п.
Желательно реализолать 2 режима: "мягкий", когда пользователь может писать всё что угодно, а редактор только подсвечивает ошибки, и "жёсткий", когда пользователь не может разбивать строки и ломать форматирования - оптимизировано для редактирования hex.

Список редакторов:
- vscode (приоритет)
- zed
- intellij idea (и все совместимые)
- kate/kwrite
- visual studio
- подсветка в популярных markdown

возможно еще какие-то варианты редакторов

## Реализация

### Грамматика должна быть описана отдельно

Я пока не знаю, каким инструменнтом описывать грамматику, пока предполагаю ANTLR или подобный. Но важно, что грамматика должна быть описана отдельно. Предполагается интеграция в разные редакторы и IDE, а из-за этого придётся писать грамматику на нескольких языках (Rust, Kotlin, TypeScript - как минимум). В идеале парсеры будут генерироваться из грамматики, но даже если не так (ANTLR вряд ли осилит), хотелось бы иметь некий референс. Необходимо проанализировать возможности генераторов парсеров.

Для грамматики должен быть полноценный набор тестов.

### Утилиты командной строки и ядро

- Утилиты командной строки и ядро пишем на rust. Производительность, переносимость, надёжность.
- Утилиты командной строки должны позволять несложно настроить автокомплит параметров в zsh, fish и т.п.
- Опции `#option` должны соответствовать ключам запуска. Также должна быть возможность настраивать их через переменные среды и держать опции в файле (json или ini или то и другое)
- Утилиты командной строки надо будет интегрировать в разные системы сборки (gradle, meson, make и т.п.)
- Конечно должны быть стандартные опции типа `--help`
- Должна быть возможность использовать pipes.

Утилиты командной строки - самая приоритетная часть реализации.

### LSP и парсер

Для подсветки синтаксиса и базовых операций с текстом нужен LSP. 
Нужно предусмотреть специальные возможности поиска и навигации (перейти на адрес, найти значение и т.п.)
У LSP и парсера должны быть опции, которые предупреждения разбора превращают в ошибки.
В далёком будущем захочется интеграировать hexator для просмотра массивов байт во время отладки в VSCode и intellij idea

### Реализации на разных ЯП

Ядро системы - конвертор bin-to-hex и hex-to-bin нужно повторить на следующих языках, скорее всего в этом порядке. В скобках - зачем.
- Rust (CLI, Zed)
- TypeScript (VSCode, markdown)
- Kotlin (Intellij)
- C#
- Python
- Go
- C++/C
- Swift

Опции командной строки CLI должны соответствовать полям (свойствам) объектов ядра. Что-то типа 
```
parserParameters.endian=LITTLE_ENDIAN;
output = parse_bin_to_hex(input, parserParameters);
```

Асинхронного или многопоточного API я пока не вижу смысла делать. Производительность всех модулей должна быть линейной от размера (и высокой). Использование памяти - в идеале типа O(1), но могут быть какие-то опции, которые этому мешают. Т.е. нельзя весь входной поток по умолчанию читать в память парсера.

### Cборка проекта

Проект получается большой и разнонаправленный, поэтому особое внимание надо уделить системе сборки самого hexator с учетом большого количества языков (возможно, внутри придётся собирать отдельными системами сборки).

### Документация и локальзация 

Документация и локальзация должны быть на английском и русском языках (обязательно) с дальнейшей локализации.

### Тестирование

все подпроекты должны быть хорошо покрыты тестами и линтерами

### Прочее

- Продумать структуру проекта
- Настроить CI
- Код в целом должен быть переносимым Linux/Windows/iOS
- Должна быть реализация Wasm
