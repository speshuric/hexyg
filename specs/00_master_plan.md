# Hexyg: Сводный план разработки (Master Plan v1.0)

Этот план предназначен для поэтапной генерации кода с помощью LLM.
**Ключевой принцип:** Сначала создаем эталонные данные (тесты), затем эталонную реализацию (Rust), затем портируем на другие языки.

## 0. Инициализация и Governance

*Подготовка фундамента, чтобы проект не превратился в хаос.*

- [x] **0.1. Определение Scope (MVP v0.1)**
    - [x] Зафиксировать в `README.md`:
        - [x] Цель: Только Hex ↔ Bin конвертация и валидация.
        - [x] Приоритет: CLI утилита (Rust).
        - [x] Редактор: Базовая поддержка VS Code (LSP).
        - [x] **Non-goals:** Пока без визуального diff, без GUI (только TUI в будущем), без сложных вложенных структур.
- [x] **0.2. Юридические и организационные вопросы**
    - [x] Выбрать лицензию (рекомендуется MIT или Apache 2.0).
    - [x] Создать файл `LICENSE`.
    - [x] Создать `CONTRIBUTING.md` (правила именования веток, коммитов).
- [x] **0.3. Настройка Монорепозитория**
    - [x] Инициализировать git.
    - [x] Настроить `.gitignore` (комбинация Rust, Node, Kotlin, Python, C#).
    - [x] Создать структуру папок:
        * `/docs` — спецификации.
        * `/grammar` — файлы грамматик.
        * `/tests/corpus` — общие тестовые данные.
        * `/crates` — Rust код.
        * `/packages` — TS/JS код.
        * `/platforms` — код для IDE (IntelliJ, VS Code).

## 1. Спецификация и Грамматика (The Truth Source)

*Прежде чем писать код, нужно договориться о правилах. Это база для промптов.*

- [ ] **1.1. Референсная грамматика (ANTLR/EBNF)**
    - [ ] Создать `grammar/hexyg.g4` (не для генерации парсера, а как документация для LLM).
    - [x] Описать токены: `ADDRESS`, `HEX_BYTE`, `COMMENT`, `DIRECTIVE` (`#option`), `ASCII_PREVIEW`.
    - [ ] Описать правила для `#struct` и метаданных `| ...` (в первой версии — как ignore или string consumption).
- [ ] **1.2. Спецификация опций**
    - [ ] Создать документ `docs/OPTIONS_SPEC.md`.
    - [ ] Расписать поведение для каждой опции:
        * `endian` (Little/Big).
        * `padding` (byte value или `forbidden`).
        * `line_length`, `block_length`.
- [ ] **1.3. Генерация "Золотого корпуса" тестов (Shared Corpus)**
    * *Критически важно для кросс-языковой разработки.*
    - [ ] Создать скрипт (Python/Shell) или вручную наполнить `/tests/corpus`:
        * `valid/`: Пары `file.bin` ↔ `file.hex` (разные опции).
        * `invalid/`: Файлы с ошибками синтаксиса, разрывами адресов (ожидается Error).
        * `edge_cases/`: Пустые файлы, файлы только с комментами, UTF-8 в комментариях.

## 2. Ядро системы (Reference Implementation: Rust)

*Эталонная реализация. Если другие порты ведут себя не так, как Rust-ядро — это баг портов.*

- [ ] **2.1. Базовая архитектура (Crate: `hexyg-core`)**
    - [ ] Определить структуру `Config` (на основе `docs/OPTIONS_SPEC.md`).
    - [ ] Реализовать трейт `HexReader` и `HexWriter` (абстракция над вводом/выводом).
- [ ] **2.2. Лексер и Парсер (Hex → Bin)**
    - [ ] Реализовать **потоковый лексер** (Iterator over Tokens). *Задача для LLM: "Напиши лексер на Rust, который принимает `&str` и выдает Enum Token, игнорируя пробелы, согласно грамматике X"*.
    - [ ] Реализовать **валидатор адресов** (проверка последовательности с учетом `padding`).
    - [ ] Реализовать **обработчик директив** `#option` (изменяет `Config` на лету).
    - [ ] **Тест:** Прогнать `tests/corpus/valid` и убедиться, что hex парсится в бинарник корректно.
- [ ] **2.3. Генератор (Bin → Hex)**
    - [ ] Реализовать форматтер с поддержкой буферизации (`BufWriter`).
    - [ ] Реализовать логику `ASCII_PREVIEW` (замена непечатных символов на `.`).
    - [ ] **Тест:** Round-trip (Bin -> Hex -> Bin должно давать исходный файл).

- [ ] **2.4. In-Memory модель (`HexDocument`)**
    *   [ ] **Структура хранения (Sparse Buffer)**
        *   [ ] Реализовать структуру на основе `BTreeMap<u64, Vec<u8>>` для эффективного хранения данных с "дырками".
        *   [ ] Реализовать логику автоматического слияния (merge) соседних чанков при записи.
        *   [ ] Реализовать логику обработки `padding`: если чтение попадает в дырку, возвращать дефолтное значение из опций или ошибку.
    *   [ ] **API доступа к данным**
        *   [ ] Реализовать методы `get_u8`, `set_u8`.
        *   [ ] Реализовать методы `read_value<T>(addr)` и `write_value<T>(addr)`, которые используют `Endianness` из настроек документа.
        *   [ ] Реализовать итератор `iter(range)`, который "перепрыгивает" через дырки или заполняет их (в зависимости от флага).
    *   [ ] **Хранение метаданных**
        *   [ ] Реализовать хранилище для комментариев и меток типов (привязка к адресу).
        *   [ ] При изменении данных (сдвиг адресов при вставке) обновлять адреса метаданных.
    *   [ ] **Конвертация DOM ↔ Stream**
        *   [ ] Реализовать метод `HexDocument::from_reader(reader)` (загрузка всего файла в память).
        *   [ ] Реализовать метод `HexDocument::write_to(&self, writer)` (выгрузка в hex-текст).    

## 3. CLI Утилита (Rust)

*Основной инструмент пользователя.*

- [ ] **3.1. Интерфейс командной строки**
    - [ ] Подключить `clap`.
    - [ ] Реализовать флаги: `--bin-to-hex`, `--hex-to-bin`, `--input`, `--output`.
    - [ ] Реализовать перекрытие опций: `Defaults` -> `Config File` -> `#option in file` -> `ENV` -> `CLI Args`.
- [ ] **3.2. I/O Pipeline**
    - [ ] Поддержка `stdin` / `stdout` для работы в пайпах (`echo "ABC" | hexyg`).
    - [ ] Корректная обработка `SIGPIPE`.
- [ ] **3.3. UX и Ошибки**
    - [ ] Красивый вывод ошибок (используя `miette` или `codespan-reporting`): "Ошибка в строке 10: Ожидался байт, найдено 'ZZ'".
    - [ ] Генерация Shell Completions (bash, zsh, fish).

## 4. LSP Сервер (Rust)

*Интеллект для редакторов.*

- [ ] **4.1. База LSP (`hexyg-lsp`)**
    - [ ] Поднять сервер на `tower-lsp`.
    - [ ] Реализовать `initialize`, `shutdown`.
- [ ] **4.2. Функциональность**
    - [ ] **Diagnostics:** Публикация ошибок парсинга (красное подчеркивание).
    - [ ] **Semantic Tokens:** Подсветка (адреса — синим, байты — желтым, ASCII — зеленым).
    - [ ] **Hover:** При наведении на hex-байт показывать его значение (Dec, Bin, Oct, Char).
    - [ ] **Formatting:** Форматирование документа (`textDocument/formatting`).

## 5. Портирование ядра (Cross-Language Core)

*Задача для LLM: "Перепиши этот Rust-код на язык X, сохраняя логику".*

- [ ] **5.1. TypeScript (для VS Code Web & Markdown)**
    - [ ] Портировать `Config` и Лексер.
    - [ ] Использовать `Uint8Array` для работы с бинарными данными.
    - [ ] Прогнать тесты из `tests/corpus` (используя Jest).
- [ ] **5.2. Kotlin (для IntelliJ Platform)**
    - [ ] Создать модуль (JVM или Multiplatform).
    - [ ] Портировать парсер (используя `ByteBuffer`).
    - [ ] Прогнать тесты из `tests/corpus` (используя JUnit).
- [ ] **5.3. Другие языки (Позже)**
    - [ ] Python (для скриптов анализа).
    - [ ] C/C++ (для встраивания в legacy).

## 6. Интеграции с редакторами

- [ ] **6.1. VS Code Extension**
    - [ ] Создать расширение.
    - [ ] Написать TextMate грамматику (regex) для быстрой подсветки.
    - [ ] Подключить Rust LSP бинарник.
    - [ ] Реализовать WebAssembly версию LSP (для запуска в браузере/github.dev) — *Advanced*.
- [ ] **6.2. IntelliJ Plugin**
    - [ ] Определить `FileType` (.hex).
    - [ ] Подключить Kotlin-порт ядра для построения PSI (Program Structure Interface).
    - [ ] Реализовать Annotator (подсветка ошибок).

## 7. Инфраструктура и Релиз

- [ ] **7.1. CI Pipeline (GitHub Actions)**
    - [ ] **Build:** `cargo build`, `npm build`, `gradle build`.
    - [ ] **Test:** Запуск тестов всех ядер на `tests/corpus`.
    - [ ] **Lint:** `cargo clippy`, `eslint`, `ktlint`.
- [ ] **7.2. Release**
    - [ ] Автоматическая сборка бинарников CLI (Linux/Windows/macOS) при создании тега.
    - [ ] Публикация в реестры: `crates.io`, `npmjs`, `VS Marketplace`.
- [ ] **7.3. Документация**
    - [ ] `docs/GRAMMAR_RU.md` и `docs/GRAMMAR_EN.md`.
    - [ ] Примеры использования в CLI.

---

### Как работать с этим планом через LLM

1.  **Начните с пункта 1.1 и 1.3.** Попросите LLM сгенерировать примеры файлов и описание грамматики. Это станет контекстом для всех следующих промптов.
2.  **Реализуйте пункт 2 (Rust Core).** Подавайте LLM грамматику и просите реализовать конкретные модули (лексер, конфиг).
3.  **Портирование (Пункт 5).** Когда Rust-код готов и отлажен, подавайте его код LLM с промптом: *"Перепиши этот модуль Rust на TypeScript, используя идиоматичные конструкции TS, но сохраняя логику байт-в-байт"*